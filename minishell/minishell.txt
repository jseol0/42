------------------readline.h 함수-----------------

# include <readline/readline.h>
# include <readline/history.h>
# include <stdio.h>
# include <stdlib.h>

int main(void)
{
	char *str;

	while(1)
	{
		/* readline함수가 호출되면 인자(prompt : )를 터미널에 출력하고 저장할 라인을 입력받는다 */
		str = readline("prompt : ");/* read함수는 저장한 문자열의 메모리주소를 반환한다 */
		if (str)/* 입력이 된다면 (주소가 존재한다면) */
			printf("%s\n", str);/* 주소안에 문자열을 출력해보자 */
		else/* str = NULL 이라면 (EOF, cntl + D)*/
			break ;/* 반복문을 탈출해준다.*/
	/* add_history에 저장된 문자열은 up & down 방향키를 이용해 확인할수있다 */
		add_history(str);
	/* 라인은 힙메모리에 저장되기때문에 다 사용한 메모리는 할당을 해제해줘야한다 */
		free(str);
	}
	return (0);
}


#include <signal.h>
#include <stdbool.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <readline/readline.h>
#include <readline/history.h>
#include <unistd.h>
#include <termios.h>

// gcc prompt_test.c -lreadline -L/usr/local/opt/readline/lib -I/usr/local/opt/readline/include

void sig_handler(int signal)
{
	if (signal == SIGINT)
	{
		//printf("\033[K"); 지워버리는 것을 원하지는 않았음.
		printf("testshell$ \n");
	}

	if (rl_on_new_line() == -1) // readline으로 설정한 문자열을 한 번 출력한다?
		exit(1);
	rl_replace_line("", 1); // 프롬프트에 이미 친 문자열을 싹 날려준다.
	rl_redisplay();         // 프롬프트 커서가 움직이지 않게 해준다.
}

void setting_signal()
{
	signal(SIGINT, sig_handler); // CTRL + C
	signal(SIGQUIT, SIG_IGN);    // CTRL + /
								 // signal(SIGTERM, sig_handler);
}

int main(int argc, char **argv, char **envp)
{
	char *str;
	struct termios term;
	tcgetattr(STDIN_FILENO, &term);
	term.c_lflag &= ~(ECHOCTL);
	tcsetattr(STDIN_FILENO, TCSANOW, &term);
	setting_signal();

	while (1)
	{
		str = readline("nanoshell$ ");
		if (!str)
		{
			printf("\033[1A");
			printf("\033[10C");
			printf(" exit\n");
			exit(-1);
		}
		else if (*str == '\0')
		{
			free(str);
		}
		else
		{
			add_history(str);
			printf("%s\n", str);
			free(str);
		}
	}
	/* 함수종료 */
	return (0);
}

------------- getcwd, chdir ------------------

#include <stdio.h>
#include <unistd.h>

int main()
{
   char buff[1024];

   mkdir( "test_A"     , 0755);           // 실행 파일이 있는 곳에 생성
   chdir( "./test_A");                    // 작업 디렉토리를 변경
   getcwd( buff, 1024);                   // 작업 디렉토리 구하기
   printf( "작업 디렉토리: %s\n", buff);
}

-------------- signal, kill ---------------------

sig_t signal(int sig, sig_t func)

#include <signal.h> 
#include <unistd.h> 
#include <stdio.h>
#include <stdlib.h>

void sig_handler(int signo)
{
	printf("\nYou can't ctrl + c me\n");
	exit(0);
}

int main()
{
	int i = 0;
	signal(SIGINT, (void *)sig_handler);
 
	while(1)
	{
		printf("%d\n", i);
		i++;
		sleep(1);
	}
	return 1;
}

---------------- stat, lstat, fstat ------------------
#include <sys/stat.h>

int stat(const char *path, struct stat *buf);
-symbolic link인 파일 path를 넘기면 원본 파일 정보를 buf에 담음

int lstat(const char *path, struct stat *buf);
-symbolic link인 파일 path를 넘기면 symbolic link 파일 정보를 buf에 담음

int fstat(int fd, struct stat *buf);
- open 함수로 열려진 파일의 정보를 buf에 담음

---------------------------------------------------------
#include <unistd.h>

int unlink(const char *pathname);
- 파일 삭제

---------------- dir 함수 -----------------------------
#include <dirent.h>

DIR *opendir(const char *filename);

struct dirent *readdir(DIR *dirp);

int closedir(DIR *dir);

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <sys/types.h>
#include <dirent.h>

int main(int argc, char **argv)
{
	DIR *dir_ptr = NULL;
	struct dirent *file = NULL;
	char home[1024];
	
	strncpy(home, getenv("HOME"), sizeof(home)); /* 목록을 읽을 디렉토리명으로 DIR *를 return 받습니다. */
	if((dir_ptr = opendir(home)) == NULL)
	{
		fprintf(stderr, "%s directory 정보를 읽을 수 없습니다.\n", home);
		return -1;
	}
	/* 디렉토리의 처음부터 파일 또는 디렉토리명을 순서대로 한개씩 읽습니다. */
	while((file = readdir(dir_ptr)) != NULL)
	{/* * struct dirent *의 구조체에서 d_name 이외에는 * 시스템마다 항목이 없을 수 있으므로 무시하고 이름만 사용합니다. */
		printf("%s\n", file->d_name);
	}
	/* open된 directory 정보를 close 합니다. */
	closedir(dir_ptr);
	return 0;
}

---------------- isatty, ttyname, ttyslot----------------
#include <unistd.h>

int isatty(int fd);
 -fd가 터미널 디바이스면 1 아니면 0 반환

char *ttyname(int fd);
 -fd 경로 반환

int ttyslot(void);
 -현재 실행하는 터미널의 tty 경로 fd 반환

#include <stdio.h>
#include <termios.h>
#include <unistd.h>
#include <fcntl.h>

int	main(void)
{
	int fd;
	char	*d;

	fd = ttyslot();
	if (isatty(fd))
		printf("aaa\n");
	d = ttyname(fd);
	printf("d - %s\n", d);
}

--------- 터미널 관련함수 getenv, tcstattr, tcgetattr, tgetent, tgoto, tputs
#include <stdlib.h>

char *getenv(const char *name);
 -환경변수에서 리스트 검색	return :포인트 스트링 반환, 실패시 errno 설정

int tcsetattr(int fd, int optional_actions, cons struct termios *termios_p);
-터미널파일fd에 대한 터미널 속성을 설정한다.
fd - 터미널 파일 기술자
optional_actions - 동작 선택
termios_p - 터미널 속성을 저장할 주소

return
성공적으로 수행하면 0,
실패하면 -1반환 errno 오류값 설정

int tcgetattr(inf fd, struct termios *termios_p);
터미널 파일fd에 대한 속성을 얻어 termios_p에 저장한다.
fd - 터미널 파일 기술자
termios_p - 터미널 속성을 저장할 주소

return
성공적으로 수행하면 0
실패하면 -1반환 errno 오류값 설정

int main(void)
{
	/* 터미널 옵션 제어 */
	struct termios term;
	tcgetattr(STDIN_FILENO, &term);
	//c_lflag 안의 옵션들은 모두 on되어있는 상태이고 엔드연산자로 off를 시킨다.
	term.c_lflag &= ~ICANON; // 이 플래그가 on되어있으면 정규모드 off면 비정규모드이다.
	// 정규모드 : 터미널 기본입력모드로 한줄씩 받는것이다. 비정규모드 : 한글자씩 받는것이다.
	term.c_lflag &= ~ECHO; // off하면 반향되지않는다. 즉 입력받지 않음 abc입력해도 안뜸
	term.c_cc[VMIN] = 1; // 한글자를 받을때까지
	term.c_cc[VTIME] = 0; // 한무대기
	tcsetattr(STDIN_FILENO, TCSANOW, &term);

	int c = 0;

	while (read(0, &c, sizeof(c)) > 0)
	{
		printf("keycode: %d\n", c);
		c = 0; // flush buffer
	}
}

-----------------------------------------------------------

1. signal_control

2. prompt 생성

3. input parsing
	'', "", ,| , (<, > ,<< : 구분자가 올때까지 입력 구분자 라인에이는 구분자만 있어야함, >>), (;   ???) 유무 check

4. (pipe 유무 or PATH 프로그램 명령어 유무)에 따라 fork 할지 안할지

5. exit status, error masage 관리


Builtin 함수

echo
cd
pwd
export
unset
env
exit